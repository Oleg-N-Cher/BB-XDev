ZXDev
=====

ZXDev - это мощная подсистема для кросс-разработки на четырёх языках для компьютера
Sinclair ZX Spectrum. Основана на оптимизирующем компиляторе высокого класса SDCC -

  http://www.z88dk.org/forum/viewtopic.php?id=4178
  http://sdcc.sourceforge.net/mediawiki/index.php/Z80_code_size

- компонентной Оберон-среде BlackBox Component Builder, а также на подсистеме Ofront,
которая умеет транслировать Оберон-модули в текст на языке Си.

Содержит утилиты и библиотеки для ZX Spectrum.

ZXDev идеально подходит как для смешанной высокоуровневой и низкоуровневой разработки,
так и для совместного использования в проектах нескольких языков программирования,
а также параллельной разработки для нескольких платформ (с ZX Spectrum включительно).

Цель проекта XDev/ZXDev — получить интегрированную среду разработки для ZX Spectrum
(и для других платформ, с единого исходника, отличаться будут только низкоуровневые
библиотеки) на различных языках программирования. Предпочтение будет отдаваться
модульным языкам, таким как Модула-2, Объектная Модула, Компонентный Паскаль.

Оберон - самый простой мультипарадигменный ОО-язык, наследник Паскаля и Модулы-2,
квинтэссенция европейской школы информатики и достижение на поприще модульных языков.


Языки разработки: Оберон, Оберон-2, Си, ассемблер процессора Z80.
Хост-платформы: Microsoft Windows 3.1 (+Win32s), Win32, Win64, Linux/Wine.
Целевые платформы: Sinclair ZX Spectrum (Z80), Win32 (PE EXE/DLL), Linux x86-32 (SO).

Планируется поддержка других языков (Модула-2, Паскаль, возможно, Компонентный Паскаль)
и кодогенерации для других платформ (UNIX/Linux, Java ME, Android).


Особенности
===========

- Поддержана плоская модель памяти Sinclair ZX Spectrum с 48Kb.
- Реализована эффективная оптимизирующая кодогенерация (средствами SDCC).


Доступные библиотеки
====================

Asm - юзаем инлайн-ассемблер из Оберона
Basic - операторы стандартного ZX-Basic
Best40 - "40 лучших процедур" от SerzhSoft. На самом деле меньше. :)
Graph - основа порта графической библиотеки Graph (из Turbo Pascal)
Laser - графические операторы расширения Laser Basic
libspr - вывод спрайтов
MegaBasic - пара операторов из Mega Basic
MiraMod2 - порт модуля GRAPH0 с Mira Modula-2 как пример Оберон-библиотеки
NewSupercode - несколько процедур из пакета "New Supercode"
PT3x0A - быстрый и короткий PT3.x Player от RSM
TRDOS - поддержка дисковых операций TR-DOS
Wham - двухголосная музыка с шумовыми эффектами на бипер

XDev - кроссплатформенный набор библиотек, совместимых с другими платформами :

  CmdLine - рудимент командной строки (для совместимости)
  Console - консольный ввод-вывод
  Control - опрос управления от клавиатуры и джойстиков
  GrApp - каркас кроссплатформенного графического приложения
  GrFonts - шрифты
  GrPixel - точечная (пиксельная) графика
  GrSpr - спрайты
  GrTiles - тайлы
  Ignore - игнорируем ненужные результаты функций без накладных расходов
  Input - ввод с клавиатуры
  Math - вещественная математика, генерация случайных чисел
  Platform - платформенно-зависимые возможности
  Sound - компактный плеер AY-эффектов от Reobne (для игры Dark Woods)
  Strings - работа со строками
  Timer - задержка времени


Быстрый старт
=============

Документация:      ZXDev/Docu
Скачать:           https://sf.net/projects/bb-xdev/files
Контроль версий:   https://github.com/Oleg-N-Cher/XDev

Форум поддержки:   http://zx.oberon2.ru/forum/viewforum.php?f=10
ZXDev на ZX.PK.ru: http://zx.pk.ru/showthread.php?t=18472
ZXDev на WoS:      http://www.worldofspectrum.org/forums/showthread.php?t=41120


Файлы .odc - это Oberon DoCument, открываются в программе BlackBox.exe,
можете ассоциировать их с ней.

Tiny HelloWorld
---------------
1. Запустить BlackBox.exe
2. File -> Open -> ZXDev/Mod/TinyHello.Mod
3. Компилируем/запускаем: F12 (откроется в эмуляторе, ассоциированном с TAP)

Размер целевого бинарника TinyHello.bin составляет 34 байт.

Если взять пустой модуль:

MODULE HelloWorld; IMPORT B := Basic; PROCEDURE Main* ; END Main; END HelloWorld.

то файл HelloWorld.bin занимает после компиляции 2 байта: #C9#C9 (RET RET).
Оверхед в один байт, что, кажется, не так уж и плохо.


"Умная" линковка (smart linking)
================================
Текущая стратегия компоновщика: прилинковывать все указанные в командной строке .rel-файлы.
Из указанных библиотек линковать только .rel-файлы, необходимые для разрешения зависимостей.

Пример:

Вы указали компоновщику rel-файлы A и B и библиотеки X и Y.
Внутри библиотеки X имеются модули X1 и X2, внутри Y имеются модули Y1 и Y2.
Предположим, что A содержит функцию f, B содержит функцию g (которая вызывает h),
X1 содержит h (которая вызывает i), и Y2 содержит i.

В этом случае A, B, X1 и Y2 будут прилинкованы к результирующей программе.

На практике это значит, что экономия кода может быть достигнута если при разработке библиотек
они вручную разделены на атомарные сущности (и представляют в итоге набор .rel-файлов,
которые могут быть зависимыми друг от друга и от других библиотек). Для не-библиотек
(и сгенерированных Ofront'ом сишных исходников), из которых порождается один .rel-файл,
поведение линкера остаётся консервативным (без умной линковки). Увы, это ограничение SDCC
(Я узнал, что такое поведение типично для многих других компиляторов Си, например Tiny C).

Ветка форума, посвящённая "умной" линковке: http://zx.oberon2.ru/forum/viewtopic.php?f=10&t=34


Полезные горячие клавиши в системе BlackBox
===========================================

(для тех, кому надо быстро)

F11
---
Транслировать текущий открытый в редакторе модуль с помощью подсистемы Ofront
с языка Оберон-2 в текст программы на Си.

F12
---
Транслировать активный документ с помощью подсистемы Ofront, если ошибок нет,
запускается одноимённый файл .bat из подкаталога Obj, который может делать работу
по линковке и запуску программы. Пример таких батников смотрите в ZXDev/Obj

Просмотр интерфейса скомпилированного модуля
--------------------------------------------
Выделите мышкой (или клавишами <-- и --> с Shift) имя модуля и выберите из меню
XDev -> Show Definition

F9
--
Сравнить два открытых файла на предмет различий (подсвечиваются).

Сделать выделенный фрагмент текста форматированием как другой текст
-------------------------------------------------------------------
Выделить текст, нажать Alt и тащить мышку на новое форматирование.


Как создать новый проект
========================

Вот начальное руководство по написанию программ для Speccy на ZXDev kit.

1) Запустите BlackBox.exe в основной папке XDev

2) File -> New (чтобы создать файл Оберон-модуля) или File -> Open (для редактирования
   существующего модуля). Готовые примеры лежат в папке ZXDev/Mod, имена файлов модулей
   имеют расширение .odc.

3) Когда всё будет готово для компиляции, сохраните модуль File -> Save (или Ctrl+S).
   Лучше если имя модуля задано латинскими буквами (русскими не проверял).

4) Теперь нажмите F11. Если в процессе компиляции возникнут ошибки, исправьте их
   и снова нажмите F11 до тех пор пока в окне Log будет что-то вроде:

   translating TinyHello    259

5) Это значит, что Ofront успешно перевёл Оберон-модуль в текст на языке Си и поместил
   файлы имя_модуля.h, имя_модуля.c и имя_модуля.sym в папку Ofront/Obj

6) Чтобы собрать одномодульный пример, работающий с библиотеками, должно хватить
   возможностей скрипта сборки по умолчанию (Bin/build.bat). Для многомодульных проектов
   придётся писать свои скрипты, описывающие логику сборки. Не нужно изобретать велосипед.
   Делайте свой скрипт по образу и подобию готовых примеров.


Благодарности
=============

- Олегу Комлеву (Saferoll) за помощь в совершенствовании XDev и за поддержку! :)

- Евгению Михайлову (HVG) и Игорю Мазнице (Raydac) за разработку и распространение
    декомпилированной командой Raydac Soft'93 A.G. библиотеки Laser Basic.

- Bernhard Treutwein - за полезные посты. Этот человек пришёл на иноязычный для него
    форум просто для того, чтобы поделиться находкой - утилитой для конвертации
    сишных заголовков (*.h) в интерфейсы для Компонентного Паскаля. Низкий поклон.

- Philipp Klaus Krause - за отличный кодогенератор для процессора Z80.

- Josef Templ - за перевод транслятора Оберона-2 в Си Ofront на FreeBSD-style-лицензию.
    Это одним махом сняло массу проблем по доработке ZXDev до любой нужной возможности.

- grischka - за продолжение совершенствования компилятора Tiny C.

- kgmcneil - за вводное руководство по созданию нового проекта и интерес к ZXDev.


Известные проблемы
==================

1. SDCC пока не умеет компилировать вот такой код присвоения структур:
   http://sourceforge.net/tracker/?func=detail&atid=350599&aid=3452891&group_id=599
   А Ofront такой код создаёт. Обещают в SDCC фичу эту добавить. Даже приоритет
   повысили несколько раз. Здесь видится несколько решений. В порядке повышения
   сложности где-то так:

   a) не использовать присваивания вида:

   TYPE
     Card = RECORD suit, rank: INTEGER END;
   VAR
     a, b: Card;
   BEGIN
     a := b;

   Обойдясь таким поэлементным присваиванием:

     a.suit := b.suit; a.rank := b.rank;

   b) использовать автоматическую обработку промежуточного Си-файла, заменив в нём
      подходящим инструментом указанные присваивания “a := b” на
      “a.suit := b.suit; a.rank := b.rank”
      Это решение не очень красивое, но плюс: Оберон-исходник остаётся красивым.

   c) ждать пока в SDCC добавят нужную нам рюху (ещё пока не добавили):
      http://sourceforge.net/tracker/index.php?func=detail&aid=1710546&group_id=599&atid=350599


   d) наиболее правильным видится доработать Ofront, чтобы сам генерировал
      поэлементное присваивание записей (или что-то вроде memcpy(a, b, sizeof(Card)) )
      [опционально включаемое]. Это вполне возможно, но требует времени. Мне кажется
      более целесообразным подождать, когда эту фичу добавят в SDCC.


TODO
====

- Добавить сжатие целевого бинарника упаковщиком Hrust 1.3


Беззнаковые типы и препроцессор
===============================
Как же без них? Функционал препроцессора предлагаю возложить на селекторы -

  DevSelectors - переключатели вариантов в исходном коде -

  http://oberoncore.ru/wiki/blackbox/devselectors
  http://forum.oberoncore.ru/viewtopic.php?f=1&t=435

Введена ограниченная поддержка беззнаковых типов. Пример использования смотрите
в ZXDev/Mod/Unsigned.odc

Известное ограничение: импортированные извне беззнаковые типы и переменные
приравниваются к знаковым.

Ввиду отсутствия интереса широкой общественности к Оберон-разработке для ZX
это направление работ свёрнуто.


Рекомендуемые соглашения
========================

Оберон, Оберон-2
----------------
1. Типы, Процедуры, Константы - называем с большой буквы; переменные - с маленькой буквы;
процедурные переменные - с маленькой буквы, даже если они являются параметрами или полями записи.
Их и так видно, что они процедуры, когда их вызываешь, – по скобкам.
Переменная – значит с маленькой буквы, всё остальное с большой. Вот моё правило. (с) Алекс Ильин

2. Не используем идентификаторов, которые целиком состоят из заглавных букв. Это мешает беглому
отделению взглядом идентификаторов от конструкций языка. Используем такие идентификаторы ТОЛЬКО
в особых случаях, чтобы подчеркнуть их особое значение. Например, в подсистеме Active BlackBox
(автор: Илья Ермаков) используются идентификаторы Ao.MONITOR, Ao.EXCLUSIVE, Ao.AWAIT, Ao.ACTIVE -
их особая роль состоит в управлении многопоточностью, поэтому они выделены на правах равнозначных
конструкций языка. Кстати, именно продемонстрированная возможность расширения языка КП введением
многопоточности (на уровне библиотеки) свидетельствует о необычайной мощности и гибкости
Оберон-технологий. Подобным же образом можно добавить любые другие конструкции, например,
для обработки исключений (последняя возможность уже встроена в ядро BlackBox).

3. В конструкциях CASE и WITH добавляем для симметрии и красоты "лишний" символ "|":

CASE c OF
  | " ": (* Space *);
  | Tab: (* Tab *);
END;

Это также повышает наглядность при восприятии программы. Это правило только для многострочной
записи. Если CASE и WITH умещается в одной строке, "лишний" символ "|" не пишем:

CASE c OF " ", Tab: ELSE (* Это не пробел и не табуляция *) END;

4. Точку с запятой ";" ставим после END всегда, за исключением случаев:

a) обязательно не ставим ";" после RETURN (если дальше END) и после EXIT (если дальше END);
b) не ставим ";" перед END если конструкция уместилась в одну строку:
   IF a = b THEN a := 2 END; (* <-- Такое системе контроля версий не страшно. *)

Обоснование: http://forum.oberoncore.ru/viewtopic.php?f=29&t=3892

Ассемблер
---------
Ассемблерные команды в сишных обвязках всегда пишем БОЛЬШИМИ буквами -
дань традиции старых 8-битных компов, в которых поначалу даже не было строчных литер,
а также классике спектрумных книг, в которых тоже придерживаются данного соглашения
(например, см. листинги в книге "Как написать игру на ассемблере для ZX Spectrum").

Если пожелаете добавить к проекту ZXDev свои разработки, следование данным соглашениям обязательно.


Отладка
=======

Я использую для отладки ASSERT'ы, и debug-вставки с отладочной распечаткой.

-------------------------------------------------------------------------------------
MODULE Sets; (* portable *)

CONST
  Debug* = TRUE;

END Sets.

MODULE Grx; (* portable *)
IMPORT Sets, Debug;
...

PROCEDURE PutSprite* (x, y: SpriteCoords; spr: Sprite);
BEGIN
  IF Sets.Debug THEN (* Это прямой аналог ifdef'а, однако если Debug = FALSE,
                        то никакого лишнего кода в прогу не вставится *)
    CASE x OF 0..MaxX: CASE y OF 0..MaxY: ELSE Debug.Stop("Bad sprite coords!") END END;
  END;
  ...
END PutSprite;

END Grx.
-------------------------------------------------------------------------------------

Для профилирования использую эмулятор FUSE. В качестве пошагового отладчика –
эмулятор Владимира Кладова EmuZWin. Так и баги в кодогенераторе SDCC искал,
так и свои проги дебажил. Я также не против иметь готовый пошаговый отладчик
Оберон-программ чисто для Z80. Осталось его написать.


Предполагаемые направления дальнейшей деятельности
==================================================

1. Адаптация к технологии  ZXDev библиотек MegaBasic, Supercode, Supercode 2 и New Supercode.
2. Адаптация к ZXDev библиотеки Sprite Pack из Z88DK ( http://www.timexsinclair.org/alvin/#SP ,    http://www.mojontwins.com/warehouse/splib2-tutorial.pdf ). Ещё посмотреть в эту сторону:
   http://www.z88dk.org/wiki/doku.php  http://www.z88dk.org/wiki/doku.php?id=library:sprites:sp1
3. Адаптация к ZXDev наработок SerzhSoft’а, в частности, “40 лучших процедур” ( http://vladik1232008.narod.ru/ZX_FORUM_40_Best_procedures.html , http://vladik1232008.narod.ru/ZX_Review11_12.html )
4. Портирование с Hisoft Pascal библиотеки для черепашьей графики Turtle.
5. Адаптация к ZXDev процедуры NiceType (красивый вывод текста) с моей игры Sea Fight  ( http://colossoft.anarxi.st/?go=seafight ).
6. Порт игры Laser Cube с Laser Basic на Оберон-2 с целью её ускорения.
7. Порт игры Dark Woods для ZX Spectrum ( http://zx.pk.ru/showthread.php?t=18457 ).
8. Адаптация для ZXDev библиотек Hisoft C и HL ZX Forth.

Следует предпринять и такие шаги:

1. Доработка Офронта для решения этой проблемы: ( http://sourceforge.net/tracker/?func=detail&atid=350599&aid=3452891&group_id=599 ).
2. Доработка Ofront до возможности полноценно использовать линейку беззнаковых типов 
   в программах на Обероне – SHORTCARD (8 бит), CARDINAL (16 бит), LONGCARD (32 бита),
   что важно для оптимальности алгоритмов при разворачивании кода на процессор Z80.
   Название типов исходит из языка Модула-2, но обсуждаемо.
3. Разработка быстрой графической библиотеки для ZX Spectrum (оконное GUI, шрифты
   разных размеров, заливка текстурой, спрайты, тайлы, векторная графика с масштабированием).
   Создание аналогичной по функционалу и по вызовам библиотеки для других платформ
   (для облегчения переноса игр со Спектрума и для одномоментной разработки
   для Спектрума и чего-то ещё).
4. Совершенствование подсистемы ZXDev для упрощения разработки (чтобы новичкам легче было
   создавать на Обероне программы для ZX Spectrum), наращивание её возможностей новыми
   библиотеками и насыщение идеями, создание информационного пространства в рамках
   технологии “ZX + Oberon”.
5. Дальнейшая доработка Офронта до транслятора, включающая поддержку языка Component Pascal,
   с возможностью использовать язык КП для программирования процессора Z80.

Я не собираюсь реализовывать всё вышеперечисленное сам, всего на свете не сделаешь,
поэтому будем посмотреть, какой это вызовет интерес и одобрение у вас. Также буду рад
услышать мнения, какие пункты считаете более приоритетными.

Прошу помощи в подготовке примеров работы для ZX на Обероне и адаптации ассемблерных
библиотек и отдельных процедур к данной технологии. Если что-то сделаете, свяжитесь,
пожалуйста, со мной.


Лицензия
========

Подсистему ZXDev разрешается использовать для любых коммерческих или некоммерческих
применений свободно. Любая помощь в работе, даже мельчайшая, будет очень кстати.
Учитывайте, что готовые компоненты, входящие в XDev, могут распространяться
под своей личной лицензией.


ЧАВО
====
Вопрос. Зачем в библиотеки включаются эти хвосты типа Best40_attrib, Best40_ASRL_LF и т.д.?

Ответ. Это нужно для совместного использования библиотек сишным компилятором. Допустим,
к проекту подключаются библиотеки Basic и Best40, в каждой из них есть функция POINT.
Получается накладка идентификаторов и "несовместимость" библиотек, невозможность использовать
их совместно без ухищрений. В Обероне, в отличии от Си, импорт квалифицированный, т.е.
с обязательным указанием модуля, откуда используется функция. И возможно совместное
использование библиотек (обращение происходит к Best40.POINT и Basic.POINT). Поэтому
чтобы при работе с библиотеками убрать влияние сишных идентификаторов друг на друга и
сохранить возможность совместного использования мы применяем жёстко заданный префикс
(Best40_ или Basic_), эмулируя квалифицированный импорт из Оберонов. Также поступает
и Ofront. В то же время, остаётся возможность из сишных частей программы вызывать
такие функции без префиксов, что реализуется с помощью препроцессора.
