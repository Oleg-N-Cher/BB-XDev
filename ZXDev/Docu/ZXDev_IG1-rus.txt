Тонкости при разработке на Обероне в среде ZXDev

   Oleg N. Cher, VEDAsoft Oberon Club

Концепция среды XDev (и её подсистемы ZXDev, нацеленной на разработку для Спектрума) формировалась в течение нескольких лет, но обрела свою реализацию в виде первой версии сравнительно недавно — в конце января 2015 г. Основные особенности:

   1. В качестве входного языка применяется язык Оберон и его надмножества — языки Оберон-2 и Компонентный Паскаль (из последнего поддержаны только некоторые фичи).

   2. Кодогенерация реализована через трансляцию Оберона в Си с последующим вызовом сишного компилятора. В качестве основного используется компилятор SDCC, но путём редактирования сборочных скриптов возможно подключение и других компиляторов, например, z88dk.

   3. Мультитаргетность. В репозитории проекта XDev ( https://github.com/Oleg-N-Cher/XDev ) есть подсистемы для таргетов MSX, MS-DOS, Windows (32/64 bit), Linux, находящиеся в разной степени готовности. Не публиковались, но также намечены подсистемы для разработки под NES/Nintendo, Java ME и Android. Уже зарелижена первая версия подсистемы ZXDev с набором библиотек в комплекте, хотя и не очень богатым, и примерами простых игр на Обероне — https://sourceforge.net/projects/bb-xdev

Оберон — это очень компактный модульный язык программирования (компонентный, объектно-ориентированный — в зависимости от диалекта) со структурной парадигмой, строгой типизацией и автоматическим управлением памятью, спроектированный для универсального применения (в том числе системного, где он заодно играет и роль скриптового языка — ОС ETH Oberon, A2/Bluebottle). Это квинтэссенция творчества классика программирования доктора Никлауса Вирта, автора Паскаля и Модулы-2. В противовес современным средствам «основного потока» (main stream) — большим языкам, ещё и наращиваемым дальнейшим усложнением, Оберон основан на самых ключевых понятиях информатики — модуль, процедура, структура данных (запись).

Оберон-парадигма так же подвержена фрагментации, как и другие области IT. Поэтому и в Оберон-парадигме есть диалекты, например, Oberon-07 (сверхминималистичная ревизия Оберона-1), OberonX (математическое расширение), Active Oberon (многопоточный диалект), Оберон-2 (с расширенными средствами ООП), а также особенно любимый мною Компонентный Паскаль (надмножество Оберона-2 для промышленного применения).


   Беззнаковые вычисления

Язык Оберон не имеет беззнаковых типов данных, это подобно тому, как процессор Z80 не имеет беззнаковых регистров или ячеек памяти. Но их значения могут интерпретироваться как беззнаковые числа и быть подвергнуты беззнаковым операциям.

Это также похоже на язык Форт — значения на стеке не обладают типом — могут трактоваться как знаковые, так и беззнаковые (или даже как двойные - занимающие два слова). И хотя большинство стековых операций знаковые, но наряду со знаковым умножением ( * ) есть и беззнаковое умножение ( U* ), так же и со сравнением, и с делением, и т.п. В общем, системного программиста не должно смутить отсутствие беззнаковых типов, ему достаточно знать, что ZXDev имеет три типа для целочисленных данных размером в 1, 2 и 4 байта. Рассмотрим, каким способом можно определить эффективные беззнаковые операции в ZXDev.

Беззнаковое сравнение байтов. Этот трюк я придумал в процессе работы над портом игры «Дурак», где применяется много знаковых сравнений байтов на больше-меньше, которые можно свободно изменить на беззнаковые сравнения, тем самым повысив эффективность кода.

Знаковое сравнение:

   IF a > b THEN ...

Беззнаковое сравнение:

   IF CHR( a ) > CHR( b ) THEN ...

Здесь знаковые значения приводятся к беззнаковому типу CHAR и потом сравниваются.

Сложение и вычитание реализуется одинаково для знаковых и беззнаковых. А вот сейчас попробуем реализовать эффективные (без накладных расходов) операции беззнакового деления и умножения для байтов и слов. Подобным образом можно реализовывать любые другие операции, отсутствующие в языке (ведь всего не предусмотришь):

MODULE UMath; IMPORT SYSTEM, B := Basic;

VAR a, b: SHORTINT;

PROCEDURE -UMultBytes (a, b: SHORTINT): SHORTINT
  "( ((unsigned char)a) * ((unsigned char)b) )";
PROCEDURE -UMultWords (a, b: INTEGER): INTEGER
  "( ((unsigned int)a) * ((unsigned int)b) )";
PROCEDURE -UDivBytes (a, b: SHORTINT): SHORTINT
  "( ((unsigned char)a) / ((unsigned char)b) )";
PROCEDURE -UDivWords (a, b: INTEGER): INTEGER
  "( ((unsigned int)a) / ((unsigned int)b) )";

BEGIN (*$MAIN*)
  B.Init; (* Приводим т.к. значение > SIZE(SHORTINT): *)
  a := SYSTEM.VAL(SHORTINT, 255);
  b := SYSTEM.VAL(SHORTINT, 255);

  B.PRWORD( UMultBytes(a, b) ); (* Печатает: 65025 (255*255) *)
  B.PRLN;

  B.PRWORD( a * b ); (* Печатает: 1 ( (-1)*(-1) ) *)
  B.PRLN;
  a := SYSTEM.VAL(SHORTINT, 255); b := 5;

  B.PRWORD( UDivBytes(a, b) ); (* Печатает: 51 (255 DIV 5) *)
  B.PRLN;

  B.PRWORD( a DIV b ); (* Печатает: 0 (-1 DIV 5) *)
  B.Quit
END UMath.

Обратите внимание на странный на первый взгляд результат процедур — UMultiBytes и остальных — он того же размера, что и аргументы. Это должно значить, что переполнение при умножении даст потерю разрядности результата, однако же на практике этого не происходит, потому что изнутри эти операции устроены так:

#define UMath_UDivBytes(a, b) ( ((unsigned char)a) / ((unsigned char)b) )
#define UMath_UDivWords(a, b) ( ((unsigned int)a) / ((unsigned int)b) )
#define UMath_UMultBytes(a, b) ( ((unsigned char)a) * ((unsigned char)b) )
#define UMath_UMultWords(a, b) ( ((unsigned int)a) * ((unsigned int)b) )

Здесь я применил при описании результата короткий тип (байт), чтобы результат был совместим с коротким типом (в случае присваивания результата переменной длиной в 1 байт) без удлинения, т.е.:

   short := UMultBytes(short1, short2);

вместо характерного для Оберона явного SHORT() для уменьшения разрядности типа (угадайте, какой вариант более эффективен?):

   short := SHORT(UMultBytes(short1, short2));

Но если тип результата имеет среднюю разрядность (слово), то, как видите, старший разряд результата не теряется:

   integer := UMultBytes(short1, short2);

(В Обероне обязательно явное указание SHORT() для уменьшения мощности числового типа; так сделано, чтобы было легче контролировать возможное искажение результата в случае приведения бОльших типов к меньшим).


   Битовые вычисления

Вирт попытался придать работе с битами более привлекательный вид, согласующийся с математическими абстракциями, поэтому биты машинного слова представлены как множество целых чисел — номеров отдельных битов ( http://oberoncore.ru/library/wirth_sets ). Для Оберона вместо универсальных множеств были выбраны множества небольших целых чисел. Тип SET в Обероне можно рассматривать как битовый набор, спроектированный так, чтобы быть независимым от порядка следования байтов платформы (так называемый byte order: most significant byte — MSB и least significant byte — LSB). Именно поэтому Оберон не поощряет насильственного приведения целых к множествам и наоборот, т.к. такое системное приведение типа — операция достаточно низкоуровневая, чтобы учитывать порядок байтов, и её использование может привести к непредсказуемым последствиям на платформах с разным порядком следования байтов, хотя конечно для Z80 это некритично.

Размер типа SET в Обероне зафиксирован в соответствии с современными процессорами и составляет 4 байта (в GPCP есть тип LONGSET = 8 байт), но в ZXDev мы можем в конфиге Ofront.par указать произвольный размер множеств, и я настоятельно рекомендую 1 байт, что наиболее эффективно для процессора Z80.

Операция MOD (остаток от целочисленного деления) при соответствующем делителе будет оптимизирована до соответствующего ей логического AND, например, обероновское a MOD 8 будет транслировано в сишное a&7.

Эквивалент логических побитовых операций для целых a и b:

   a AND b = ORD(BITS(a) * BITS(b))
   a XOR b = ORD(BITS(a) / BITS(b))
   a OR b = ORD(BITS(a) + BITS(b))
   NOT a = ORD(-BITS(a))

Где ORD — это преобразование битового множества в целое, а BITS — целого во множество. Идеология Оберона не поощряет работу с целыми как с битами и наоборот, ибо это, по мнению Вирта, ведёт к неряшливому использованию типов и нивелирует преимущества строгой типизации, поэтому функций BITS() и ORD(set) в стандарте Оберона нет, но есть в Компонентном Паскале (и в XDev тоже).

   IF 0 IN set THEN (* if(set & 1) ... *)
   IF BITS(23H) * set # {} THEN (* if (set & 0x23) ... *)
   IF {0, 1, 5} * set # {} THEN (* if (set & 0x23) ... *)

Последний вариант, как мне кажется, более наглядно показывает, что в наборе проверяется состояние битов №№ 0, 1 и 5. Пусть вас не вводит в заблуждение некоторая вычурность записи битовых операций, особенно это кажущееся «умножить» — машкод получается что надо:

; if ((0x23 & _set) != 0x0) {
        ld  a,(#_set + 0)
        and a, #0x23
        jr  Z, ...

Таким образом, на Обероне можно сделать достаточно низкоуровневую программу, например, эмулятор Спектрума.


   Константные массивы

Для включения ресурсов и двоичных данных прямо в код Оберон не предлагает ничего лучше, чем поэлементное присваивание. И я очень благодарен Олегу Комлеву (Saferoll) за его труд по добавлению в ZXDev нестандартного языкового расширения — константных массивов. Дадим ему слово:

Saferoll:

Что удалось сделать по константным массивам на данный момент — май 2015 года.

   1) Константные массивы любой вложенности.

   2) Типы элементов — линейка целых типов (включая BYTE), BOOLEAN или CHAR. Все эти типы в C-исходнике становятся целыми константами.

   3) Если массив состоит из CHAR или BYTE, то элементы можно указывать либо как перечень символов в скобках ('f', 20X, "7"), либо в виде строки "ab" без лишних скобок. Но строка обязательно подразумевает в конце символ 0Х, для него тоже должно быть место в массиве!

Ставить в кавычках меньше символов можно, тогда символы после 0X могут быть заполнены мусором — зависит от реализации Си-компилера. Поэтому лучше считать, что неиспользуемый строкой остаток массива заполнен неопределёнными символами.

Пустую строку "" можно указывать для любого массива ARRAY N OF CHAR (или ARRAY N OF BYTE).

Примеры:

   TYPE
     MsgStr = ARRAY 3, 7 OF CHAR;
   CONST
     Way = MsgStr("Hello","Error","Try");
   TYPE
     Labirint = ARRAY 3, 16 OF CHAR;
   CONST
     Map = Labirint(
       "...o..##...oo12",
       "...o..##...oo35",
       "...o..##...oo78"
     );

Пока не сделано: экспорт константных массивов (с этим мы ещё не разобрались), возможность опускать размер массива, чтобы Ofront автоматически его рассчитал по количеству элементов, и указание $ на фиксированный символьный массив. Чую, что тут опять полезут проблемы с путаницей «символ или строка». Также есть куда развивать реализацию в смысле эффективности. Но то, что сделано сейчас, уже весьма полезно.


   Совместное использование Оберона и Си

В Оберон-программы можно вставлять произвольные части кода, написанные на языке Си (и встроенном ассемблере). Есть несколько способов ( http://zx.oberon2.ru/forum/viewtopic.php?f=10&t=202 ), которые я кратко перечислю.

   1. Прямая вставка сишного файла в Оберон-программу

IMPORT SYSTEM;
PROCEDURE -includemain '#include "Main.c"';

// --- Main.c ---
void main (void) {
   Basic_Init();
   Laser_InitScroll(65392);
   Laser_InitSprites(Rsrc_SprStart, 4769);
   ...
   Basic_Quit();
}

Разумнее всего будет вставлять так отдельные функции, хотя может оказаться, что этот способ имеет гораздо более широкие возможности. Просто нужно учитывать то, что Оберон-модуль как-то должен знать про этот сишный код, чтобы уметь с ним взаимодействовать.

Как мы знаем, Оберон-строки являются нуль-терминированными, но в отличие от сишных к ним прикреплено значение максимальной длины строки. Если процедуры для работы со строками всегда будут действовать в рамках этой длины — код всегда будет работать корректно. Но можно ли работать на Обероне со строками целиком в сишном стиле без дополнительного поля макс. длины? Конечно можно. Вот мы опишем вызовы сишных функций в обёртке обероновских процедур, и они могут даже не совпадать по параметрам (см., например, IntToStr):

TYPE
  CString = SYSTEM.PTR; (* C-like null-terminated string. *)

PROCEDURE -includestdlib "#include <stdlib.h>";
PROCEDURE -includestring "#include <string.h>";
PROCEDURE -Length (str: CString): INTEGER "strlen((char*)str)";
PROCEDURE -CopyStr (dest, src: CString) "strcpy((char*)dest, (char*)src)";
PROCEDURE -IntToStr (n: INTEGER; str: CString) "_itoa(n, (char*)str, 10)";
PROCEDURE -UIntToStr (u: INTEGER; str: CString)
              "_uitoa((unsigned int)u, (char*)str, 10)";
PROCEDURE -Concat (dest, src: CString) "strcat((char*)dest, (char*)src)";

Пример использования:

IMPORT SYSTEM, B := Basic;
CONST
  MaxIntSize = 7; (* "-12345" + 0X. *)
VAR
  num: SHORTINT;
  strBuf: ARRAY MaxIntSize OF CHAR; (* Convert integer to string. *)
BEGIN
  num := B.RND(1, 4);
  UIntToStr(num, SYSTEM.VAL(CString, SYSTEM.ADR(strBuf)));
  Concat(SYSTEM.VAL(CString, SYSTEM.ADR(strBuf)),
    SYSTEM.VAL(CString, SYSTEM.ADR(" is my number"))
  );


   2. Биндинг

Чтобы Оберон умел взаимодействовать с кодом на Си — нужно как-то к нему прикрепиться. Необходимо сделать описание интерфейса сишной библиотеки в стиле Оберон-модуля, чтобы другие модули могли вызывать из него процедуры, брать значение констант и т.д. Для этого мы должны подготовить биндинг-связку, в которой будет описан интерфейс чужеродного модуля, все константы, типы и процедуры (в случае XDev — с пустыми телами). Замечу, что это обычная практика для связки модульных языков с сишными библиотеками (применяется не только в Оберонах, но и в языках Ада, Модула-2, Модула-3).

XDev содержит достаточные средства для создания биндингов, учитывающие возможность использовать разные модели вызова функций, замену одних вызовов другими, описание прототипов функций и т.д. С их помощью созданы биндинги к WinAPI и libSDL для XDev/WinDev. Приведу пример простого биндинга, отсылая за деталями к форуму http://zx.oberon2.ru/forum/viewtopic.php?f=10&t=94.

MODULE Input; IMPORT SYSTEM;

CONST
   Backspace* = 0CX;
   Enter* = 0DX;
   Escape* = "E";
   Space* = " ";
   (* Arrows *)
   Up    * = "Q";
   Down  * = "A";
   Right * = "P";
   Left  * = "O";

TYPE
   Key* = CHAR;

(** Returns the number of keystrokes in the keyboard input buffer. *)
PROCEDURE Available* (): SHORTINT;
BEGIN RETURN 0 END Available;

(** Read a key from the keyboard buffer. Blocks if no key is available. *)
PROCEDURE Read* (): Key;
BEGIN RETURN 0X END Read;

PROCEDURE RunMe50Hz* ; END RunMe50Hz;

END Input.

Транслятор сгенерирует из этого биндинга сишный файл с пустыми телами функций, а также более нужные нам 1) заголовочный файл Obj/Input.h, который будет подключен при компиляции, и 2) символьный файл Sym/Input.sym, подобный таким же, сгенерированным для родных Оберон-модулей. В нём хранится закодированное представление интерфейса модуля. Автосгенерированную пустую сишную реализацию мы игнорируем, подменяя при компиляции на реализацию, написанную ручками (на Си или асме), которая хранится в папке /C и реализует заявленную в интерфейсе функциональность.

   3. Биндинг с использованием готового сишного стандартного заголовка и самодельного заголовка-переадресовщика

Допускаю и такую вариацию: при необходимости можно игнорировать и автосгенерённый Оберон-транслятором заголовок (*.h). Делается модуль-биндинг на Обероне (для получения символьного файла), а при компиляции подключается сделанный вручную заголовочный сишный файл, из которого 1) уже в свою очередь инклюдится стандартный сишный заголовок, не адаптированный к оберонскому манглированию имён префиксом и т.п.; и 2) в котором описывается переадресация Оберон-процедур в сишные функции или даже макросы. Подобным образом устроен биндинг к библиотеке trdos.lib (см. в дистрибутиве ZXDev).


   Сопряжение с ассемблером

   Передача параметров

Передача параметров в регистрах в SDCC не реализована, хотя Филипп Краузе и обещал над этим подумать. Параметры функциям передаются в стеке, верхним хранится адрес возврата. Есть несколько способов получить параметры, и вам необходимо выбрать наиболее приемлемый. Если параметр(ы) занимает(ют) 1 или 2 байта, то неплохим будет такой код:

   POP  HL ; Адрес возврата
   POP  BC ; Однобайтовый параметр — в C,
   PUSH BC ; а если двухбайтовый, то в BC
   PUSH HL ; Если в процедуре HL не
           ; портится, то можно заменить
           ; PUSH HL:RET на JP (HL)

Или же так (такты и байты считайте сами):

   LD   HL,#2
   ADD  HL,SP
   LD   C,(HL) ; 1-й байт параметра(ов)
   INC  HL
   LD   B,(HL) ; 2-й байт параметра(ов)

Если глубоко в теле подпрограммы требуется получение параметров в произвольном порядке, то, возможно, более оптимальным будет адресовать параметры через IX:

   PUSH IX
   LD   IX,#0
   ADD  IX,SP
   LD   C,4(IX) ; 1-й байт параметра(ов)
   LD   B,5(IX) ; 2-й байт параметра(ов)
   ...
   POP  IX

Функция не должна извлекать свои параметры из стека совсем, — в модели вызова по умолчанию компилятор сам извлекает параметры после возвращения из функции (что в ряде случаев помогает ему оптимизировать код). Также функция не должна разрушать содержимое регистра IX, через который SDCC работает с локальными переменными.

Результат функций в зависимости от размера возвращается в регистре L, в паре HL или в DE:HL.

   Эффективный вид Z80-кода, подходящий для портирования

Коснёмся такого интересного вопроса, как портирование Спектрум-игр на другие платформы. Не секрет, что код на ассемблере не слишком нагляден, но зато слишком объёмен. И для прояснения его логики часто приходится очень подробно разбирать огромные куски кода, пытаясь понять и описать, что они делают. Результаты такой кропотливой работы не грех задокументировать, переписывая на более высокоуровневый язык, и здесь нам может помочь XDev, который предоставляет язык достаточно простой, чтобы быть развёрнутым на других платформах, но и достаточно современный концептуально, ибо, несмотря на свой почти 30-летний возраст, прекрасно ложится практически на все современные аппаратные и программные платформы, что я демонстрировал примерами мидлетов на Обероне ( http://zx.oberon2.ru/forum/viewtopic.php?f=27&t=38 ) и даже некоторыми подвижками в разработке для Android ( http://zx.oberon2.ru/forum/viewtopic.php?f=87&t=244 ). А вот, например, Си, насколько мне известно, нельзя транслировать в байт-код Dalvik и в Java .class'ы, ибо Си имеет слишком много опасных возможностей, от которых в Java-машинах постарались избавиться на уровне байт-кода. То же самое можно сказать о браузерных приложениях. Оберон же прекрасно ложится даже на микроконтроллеры ( http://www.youtube.com/watch?v=zlnj6FCY1tY ), не говоря уж о JVM и .NET ( http://gpcp.codeplex.com ).

К сожалению, формат журнальной статьи не позволяет развёрнуто описать процессы миграции Z80-кода на другие платформы, но если вам интересно, как могут выглядеть интерфейсы библиотек и прикладной код, транслируемый в различные (очень различные!) таргеты, то смотрите среду XDev (и её подсистемы для разработки под разные платформы) и среду Monkey X ( http://monkey-x.ru ), которая также предлагает трансляцию с единого языка под различные таргеты, что при всех недостатках реализации (ей далеко до универсальности, но всё нужно развивать) экономит время и ресурсы, которые в противном случае тратились бы на изучение десятков (быстроменяющихся) языков, платформ и их API.

Ещё хотелось бы отметить, что я не видел ни одного удовлетворительного решения для одномоментной разработки для Спека и других платформ. Вы можете возразить, что никого не интересует скрещивание Спека с ПЦ. Я же могу возразить в ответ — а почему одинаковая программа или игра должна быть написана по-разному для разных платформ? И особенно на разных языках, которых сейчас как собак нерезаных. Устаю удивляться, когда просто читаю новые названия языков. Не кроется ли здесь проблема, которой вы не заметили?

Так почему же я не считаю Си таким хорошим средством для одномоментной разработки. Во-первых, см. выше о том, как Си ложится на современные платформы, а, вернее, уже не ложится. Во-вторых, посмотрите непредвзятым взглядом на исходники любой игрушки для Спектрума, написанной на Си [ну, не считая игр на движке Churrera — Ред.]. Вы не обращали ранее внимания на обилие вставок на асме? Так вот, я вас уверяю: это приговор. Хотя и приятно, что не целиком всё на асме. В общем, не видел ни одного средства разработки, при помощи которого удалось бы хотя бы частично автоматизировать процесс вытаскивания игры из рамок спектрумных ограничений. Нужно всё переписывать заново. XDev тоже не является таким средством, но Оберон как язык при всей жёсткости его каркаса и обилии ограничений — в общем-то хорошая основа для мультитаргетной разработки, как мне кажется. Но предстоит изучение его возможностей в этом плане и, разумеется, их совершенствование. Важно понимать, что я не предлагаю панацею, просто обозначаю проблему и призываю искать пути её решения, если вам это интересно.

Мы мигрируем от Z80-асма к Си, но, не найдя в нём достаточной опоры для прикладного высокоуровневого программирования — безопасного, наглядного средства для программ со сложной структурой и мета-программирования (скриптования) ( http://forum.oberoncore.ru/viewtopic.php?f=6&t=5267 ), оставаясь в рамках компилируемого кода, мы движемся дальше, к Оберону, но оставляем за собой возможность юзать для низкого уровня и асм, и Си, и Java, если понадобится (последнее не для ZX конечно, а для Java-based платформ). Вот поэтому я вижу язык Си в применении к другим платформам в роли асма Z80 для Спека. Хорошо для низкого уровня, но начинает нервировать, когда идёт работа со сложной прикладной логикой.

С учётом того, что к коду на Z80 хорошо бы приложить удобный и однозначно соответствующий логике асмовского код на языке высокого уровня, а главное — компилируемый и исполняемый (а в идеале — ещё и кроссплатформенный!), оставляя за бортом упоминание о множестве проблем совместимости и различий по библиотекам, интерфейсам и ещё много чего, просто покажу, как может выглядеть код, реализующий игру для Спектрума/Z80 и других платформ одномоментно, вовсе не утверждая, кстати, что XDev — идеальная среда для этих применений (в этот момент асмеры кричат "маздай" и бьются в пароксизмах ЯВУ-ненавистничества в применении к Спектруму).

Итак, вот процедура опроса клавиатуры из игры "Дурак" от CopperFeet, портированная на Оберон с Laser Basic'а, а потом дополненная альтернативной реализацией на ассемблере:

MODULE Durak;
IMPORT M := Asm, B := Basic, Cfg;

TYPE KeyCode = CHAR; VAR time: INTEGER;

(* Scan keys & return a control code: *)
PROCEDURE GetKey (): KeyCode;
BEGIN
  IF Cfg.Oberon THEN

    (* ~ 2 min 50 sec to play music: *)
    B.PAUSE(9); DEC(time, 9);
    (* <Y>, <U>, <I>, <O>, <P>: *)
    IF BITS(B.PORTIN(0DFFEH))*BITS(1FH)
      # BITS(1FH) THEN RETURN 2X END;
    (* <Q>, <W>, <E>, <R>, <T>: *)
    IF BITS(B.PORTIN(0FBFEH))*BITS(1FH)
      # BITS(1FH) THEN RETURN 1X END;
    (* <A>, <S>, <D>, <F>, <G>:  *)
    IF BITS(B.PORTIN(0FDFEH))*BITS(1FH)
      # BITS(1FH) THEN RETURN 3X END;
    (* <H>, <J>, <K>, <L>, <Enter>: *)
    IF BITS(B.PORTIN(0BFFEH))*BITS(1FH)
      # BITS(1FH) THEN RETURN 4X END;
    (* <B>, <N>, <M>, <SS>, <Space>: *)
    IF BITS(B.PORTIN( 7FFEH))*BITS(1FH)
      # BITS(1FH) THEN RETURN 5X END;

  ELSE

    (* B.PAUSE(9): *)
    M.Code("LD   HL, #9                 ");
    M.Code("CALL _Basic_PAUSE_DI        ");
    (* DEC(time, 9): *)
    M.Code("LD   HL, (_Durak_time)      ");
    M.Code("LD   DE, #0-9               ");
    M.Code("ADD  HL, DE                 ");
    M.Code("LD   (_Durak_time), HL      ");
    (* <Y>, <U>, <I>, <O>, <P>: *)
    M.Code("LD   BC, #0xDFFE            ");
    M.Code("IN   A, (C)                 ");
    M.Code("CPL                         ");
    M.Code("AND  #0x1F                  ");
    M.Code("LD   L, #2                  ");
    M.Code("RET  NZ                     ");
    (* <Q>, <W>, <E>, <R>, <T>: *)
    M.Code("DEC  L                      ");
    M.Code("LD   BC, #0xFBFE            ");
    M.Code("IN   A, (C)                 ");
    M.Code("CPL                         ");
    M.Code("AND  #0x1F                  ");
    M.Code("RET  NZ                     ");
    (* <A>, <S>, <D>, <F>, <G>:  *)
    M.Code("LD   BC,#0xFDFE             ");
    M.Code("IN   A, (C)                 ");
    M.Code("CPL                         ");
    M.Code("AND  #0x1F                  ");
    M.Code("LD   L, #3                  ");
    M.Code("RET  NZ                     ");
    (* <H>, <J>, <K>, <L>, <Enter>: *)
    M.Code("INC  L                      ");
    M.Code("LD   BC, #0xBFFE            ");
    M.Code("IN   A, (C)                 ");
    M.Code("CPL                         ");
    M.Code("AND  #0x1F                  ");
    M.Code("RET  NZ                     ");
    (* <B>, <N>, <M>, <SS>, <Space>: *)
    M.Code("INC  L                      ");
    M.Code("LD   BC, #0x7FFE            ");
    M.Code("IN   A, (C)                 ");
    M.Code("CPL                         ");
    M.Code("AND  #0x1F                  ");
    M.Code("RET  NZ                     ");
  END;

  RETURN 0X
END GetKey;

END Durak.

Что любопытно, асмовский код, конечно, компактнее, но если сжать это дело Hrum'ом, то в результате сжатая обероновская реализация по размеру меньше, чем сжатая асмовская. Что позволяет сделать смелый вывод: при достаточном количестве памяти и быстродействии в случае загрузки машинного кода в уже сжатом виде (и при разумной скорости распаковки) остаётся экономить лишь адресное пространство, которое в таком случае и является основным ресурсом для экономии и самым весомым аргументом за асм-реализацию в случае его недостаточности, тогда как для некоторых проблем важнее иметь не столько экономию адресного пространства, сколько бОльшую простоту и гибкость разработки (макетирование, прототипирование, средства отладки и т.д.). [Впрочем, мы можем использовать интерпретируемый пи-код для экономии адресного пространства, потеряв при этом в скорости — Ред.]


   Возможности Оберон-языков, отсутствующие в ZXDev

Есть ряд возможностей Оберона, которые вряд ли будут когда-либо реализованы для разработки под процессор Z80. Это динамическая модульность (загрузка-выгрузка модулей "на лету"), автоматическое управление памятью (сборка мусора; но пользоваться динамической памятью всё-таки можно, явно освобождая её с помощью Platform.DISPOSE), возможности ядра по мета-программированию, обработке исключений, моментальной (посмертной) отладке и т.д. Как вы понимаете, скорости и памяти (особенно адресного пространства) Z80 явно недостаточно, чтобы в полной мере почувствовать прелесть разработки на Оберон-языках.
